PROJECT: Offline-First PWA Storefront

1) Technologies Used:
  a) Frontend (Client):
    React.js: For building the user interface with components.
    Vite: As the frontend build tool and development server.
    Material-UI (MUI): As the component library for a modern, responsive UI.
    React Router: For client-side routing and navigation.
    Axios: As the HTTP client for making API requests.

  b) Backend (Server):
    Node.js & Express.js: As the runtime and framework for the REST API.
    MongoDB: As the NoSQL database for users, products, and orders.
    Mongoose: As the ODM library for schema definition and database interaction.

  c) PWA & Offline Features:
    Service Workers: Managed via vite-plugin-pwa (Workbox) to handle caching and background sync.
    IndexedDB: Using the idb library for client-side storage (offline cart).
    Background Sync API: To queue offline checkouts and sync when connectivity returns.

  d) Authentication:
    JSON Web Tokens (JWT): For securing API endpoints and managing user sessions.
    bcrypt.js: For hashing user passwords.

2) Project Overview:
  a) This project is a full-stack, offline-first Progressive Web App (PWA) designed to replicate a modern e-commerce storefront.
  b) The primary goal is to provide a seamless user experience, even with an unreliable or non-existent internet connection. Users can browse products, manage their cart, and even "check out" while completely offline.
  c) It demonstrates an advanced "offline-first" architecture where UI updates are optimistic, data is stored locally in IndexedDB, and actions are queued.
  d) The key feature is the Background Sync API, which automatically detects when the network is restored and syncs any pending offline orders with the backend server, ensuring no data is lost.
  e) The application includes full user authentication with JWT, protected routes, and a server-synced cart for logged-in users.


3) Project File Structure: The project follows a standard MVC (Model-View-Controller) pattern to keep the code organized, scalable, and easy to maintain.

        pwa-storefront/
        ├── backend/
        │   ├── middleware/
        │   │   └── auth.js             # JWT verification middleware
        │   ├── models/
        │   │   ├── User.model.js       # Schema for users (with nested cart)
        │   │   ├── Product.model.js    # Schema for products
        │   │   └── Order.model.js      # Schema for orders
        │   ├── routes/
        │   │   ├── auth.js             # Login/Register endpoints
        │   │   ├── products.js         # Product fetching endpoints
        │   │   ├── cart.js             # Server-side cart sync endpoints
        │   │   └── orders.js           # Checkout & order history endpoints
        │   └── index.js                # Main backend server entry point
        │
        ├── frontend/
        │   ├── src/
        │   │   ├── components/
        │   │   │   ├── ProductCard.jsx
        │   │   │   ├── Sidebar.jsx
        │   │   │   ├── ProtectedRoute.jsx
        │   │   │   └── OfflineBanner.jsx
        │   │   ├── context/
        │   │   │   └── AuthContext.jsx   # Global state for auth & user
        │   │   ├── pages/
        │   │   │   ├── HomePage.jsx
        │   │   │   ├── CartPage.jsx
        │   │   │   ├── LoginPage.jsx
        │   │   │   └── OrdersPage.jsx
        │   │   ├── utils/
        │   │   │   └── db.js             # IndexedDB helper functions
        │   │   ├── App.jsx               # Main router setup
        │   │   ├── main.jsx              # React app entry point
        │   │   └── sw.js                 # Custom Service Worker logic
        │   ├── vite.config.js          # Vite & PWA plugin configuration
        │   └── package.json
        │
        └── package.json                # Root package (if any)


4) Structure: 
     SNIPPETS:

    i) Service Worker Caching (vite.config.js & sw.js): Instead of auto-generation, we use the injectManifest strategy. 
       This gives us full control over a custom sw.js file for advanced features like Background Sync, while still allowing Workbox (via Vite) to inject the pre-cache manifest for the app shell.
      SNIPPET (frontend/vite.config.js):
          import { VitePWA } from 'vite-plugin-pwa';

          export default defineConfig({
            plugins: [
              VitePWA({
                strategy: 'injectManifest', // Use our custom SW file
                srcDir: 'src',
                filename: 'sw.js', // The name of our custom file
                registerType: 'autoUpdate',
                // ... manifest options ...
              })
            ]
          });

   ii) Offline Data Storage (IndexedDB): All cart operations are routed through a helper (utils/db.js) that uses the idb library. This allows the user to add/remove items from their cart even when offline.
      
      SNIPPET (routes/products.js):   
        import { openDB } from 'idb';

        const DB_NAME = 'pwa-store-db';
        const CART_STORE = 'cart-items';

        async function initDB() {
          return openDB(DB_NAME, 2, { // Version 2
            upgrade(db, oldVersion) {
              if (oldVersion < 1) {
                db.createObjectStore(CART_STORE, { keyPath: 'productId' });
              }
              if (oldVersion < 2) {
                db.createObjectStore('sync-queue', { autoIncrement: true, keyPath: 'id' });
              }
            },
          });
        }

        // Function to add/update an item in the local cart
        export async function addOrUpdateCartItem(item) {
          const db = await initDB();
          const tx = db.transaction(CART_STORE, 'readwrite');
          const store = tx.objectStore(CART_STORE);
          
          const existingItem = await store.get(item.productId);
          if (existingItem) {
            existingItem.quantity += item.quantity;
            await store.put(existingItem);
          } else {
            await store.put(item);
          }
          return tx.done;
        }

   iii) Background Sync (The Core Offline Feature): This is the most critical PWA feature. When a user tries to checkout offline, the action is saved to an IndexedDB "sync-queue." We then register a "sync" event with the service worker. When the browser detects connectivity, the service worker wakes up, processes the queue, and sends the order to the server.
             
      SNIPPET (frontend/src/pages/CartPage.jsx):
        const queueCheckout = async (orderData) => {
          const action = { type: 'checkout', payload: orderData };
          await addToSyncQueue(action); // Save to IndexedDB

          // Register the sync tag with the Service Worker
          if ('serviceWorker' in navigator && 'SyncManager' in window) {
            const swRegistration = await navigator.serviceWorker.ready;
            await swRegistration.sync.register('sync-new-order');
          }
          
          alert("You are offline. Your order will be placed when you're back online!");
          // ... (clear local cart & navigate)
        };

    iv) Authentication & Protected Routes: The app uses React Context to manage a global authentication state (token, user data). A custom ProtectedRoute component wraps private pages, redirecting unauthenticated users to the login page.ngoDB feature. 
      It finds products based on a property inside the nested variants array. It also uses projection ($elemMatch) to return only the specific variant that matches the query.
            
      SNIPPET (frontend/src/components/ProtectedRoute.jsx):      
        import React, { useContext } from 'react';
        import { AuthContext } from '../context/AuthContext';
        import { Navigate, Outlet } from 'react-router-dom';

        function ProtectedRoute() {
          const { token, loading } = useContext(AuthContext);

          if (loading) {
            return <h2>Loading...</h2>;
          }

          // If no token, redirect to login
          if (!token) {
            return <Navigate to="/login" replace />;
          }

          // If token exists, render the child route (e.g., HomePage)
          return <Outlet />;
        }

5) Learning Outcomes:
    a) Mastered the design and implementation of a full-stack MERN application.
    b) Gained practical experience with Progressive Web App (PWA) principles, including the Web App Manifest and Service Worker lifecycle.
    c) Implemented an offline-first architecture using caching strategies (StaleWhileRevalidate, CacheFirst).
    d) Learned to use IndexedDB for robust client-side data storage (offline cart).
    e) Successfully implemented the Background Sync API to queue offline actions and guarantee data sync.
    f) Built a secure, token-based authentication system (JWT) with password hashing (bcrypt).
    g) Managed complex application state (auth, user, cart) using React Context.

6) Key Concepts:
    a) Progressive Web Apps (PWA)
    b) Service Workers
    c) Offline-First Architecture
    d) Background Sync API
    e) Client-Side Caching
    f) IndexedDB (idb library)
    g) REST API Development (MERN Stack)
    h) Token-Based Authentication (JWT)