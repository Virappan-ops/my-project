PROJECT: Connecting React Frontend to Express API Using Axios

1) Technologies Used:
    a) Backend: Node.js, Express.js.
    b) Frontend: React (using Vite), JavaScript (ES6+), Axios.
    c) Styling: CSS for a clean, dark-themed UI.
    d) Testing: Postman (for API endpoint verification), Web Browser.

2) Project Overview:
    a) This project is a fundamental full-stack application that demonstrates how to connect a client-side React application to a server-side Express API.
    b) The backend's sole responsibility is to provide a list of products via a RESTful API endpoint. The product data is stored in-memory on the server.
    c) The frontend uses the Axios library to make an HTTP GET request to the backend. It effectively handles asynchronous operations by displaying loading and error states before rendering the final product list.
    d) This application serves as a perfect starting point for understanding the core principles of client-server communication in modern web development.

3) Project File Structure: 

      fullstack-integration/
        └── Experiment-7.1/
            ├── backend/
            │   ├── node_modules/
            │   ├── package.json
            │   ├── package-lock.json
            │   └── server.js           # Express API server
            │
            └── frontend/
                ├── node_modules/
                ├── public/
                ├── src/
                │   ├── App.css         # Styling for the application
                │   └── App.jsx         # Main React component
                ├── .gitignore
                ├── index.html
                ├── package.json
                └── vite.config.js


4) Structure: 
    Application Loop & In-Memory Data:
      a) The application follows a simple request-response model. When the React app loads, a useEffect hook triggers an API call using Axios. 
      b) The Express server receives this request, sends back the product data as JSON, and the React app updates its state, causing the UI to re-render and display the products.
            
     SNIPPETS:

    i) Backend: Express API Endpoint (server.js):
     This snippet defines the /api/products route. When a GET request is made to this URL, the server responds with the hardcoded products array.
      
      SNIPPET (server.js):
        // The product data
        const products = [
          { id: 1, name: 'Laptop', price: 1200 },
          { id: 2, name: 'Mouse', price: 25 },
          { id: 3, name: 'Keyboard', price: 45 },
        ];

        // The API endpoint to get the products
        app.get('/api/products', (req, res) => {
          console.log(`Request received for products on port ${PORT}.`);
          res.json(products);
        });


   ii) Frontend: Fetching Data with Axios (App.jsx):
    The useEffect hook is used to perform the data fetching side-effect when the component mounts. Axios handles the GET request, and .then(), .catch(), and .finally() are used to manage the response.
      
      SNIPPET (App.jsx):   
        // useEffect to fetch data when the component mounts
        useEffect(() => {
          // Fetch data from the backend API
          axios.get('http://localhost:5001/api/products')
            .then(response => {
              // On success, update the products state
              setProducts(response.data);
            })
            .catch(err => {
              // On error, set an error message
              setError('Failed to fetch data. Make sure the backend server is running.');
            })
            .finally(() => {
              // Set loading to false after the request finishes
              setLoading(false);
            });
        }, []); // The empty array [] means this runs only once


   iii) Frontend: Rendering the UI (App.jsx): 
     This JSX code snippet shows how the component conditionally renders loading or error messages.
     Once the data is available, it maps over the products array in the state to create a product card for each item.
             
      SNIPPET (App.jsx):
        // Show a loading message
        if (loading) {
          return <h1>Loading...</h1>;
        }

        // Show an error message
        if (error) {
          return <h1 style={{ color: 'red' }}>{error}</h1>;
        }

        // Render the product list
        return (
          <div className="App">
            <h1>Product List</h1>
            <div className="product-container">
              {products.map(product => (
                <div key={product.id} className="product-card">
                  {/* ...product details... */}
                </div>
              ))}
            </div>
            <footer>...</footer>
          </div>
        );


5) Learning Outcomes:
    a) Learned how to create a basic REST API endpoint using Node.js and Express.
    b) Understood how to make HTTP requests from a React application using the Axios library.
    c)  Practiced handling asynchronous operations, including loading and error states, in a frontend application.
    d) Gained experience in managing and displaying data from an API using React state and props.
    e) Understood the importance of CORS for enabling client-server communication between different origins.

6) Key Concepts:
    a) Full-Stack Application
    b) REST API Design
    c) Client-Server Architecture
    d) Asynchronous JavaScript (Promises)
    e) React Hooks (useState, useEffect)
    d) Conditional Rendering
    e) HTTP GET Method


7) Sample API & App Test:
    API Test (Postman):
      Request: GET http://localhost:5001/api/products
      Expected Response (✅): A 200 OK status and a JSON array containing the three product objects.

    Frontend App Test (Browser):
      Step 1: Run the backend server (node server.js).
      Step 2: Run the frontend development server (npm run dev).
      Step 3: Open the provided URL (e.g., http://localhost:5173) in your browser.
      Expected Result (✅): After a brief "Loading..." message, the page displays three product cards for "Laptop," "Mouse," and "Keyboard," followed by the footer.

8) Conclusion
  a) This project serves as a clear and concise demonstration of a fundamental pattern in web development: fetching data from a backend API to be displayed on a frontend interface.
  b) It is an essential building block that provides the foundation for creating more dynamic and data-driven applications.